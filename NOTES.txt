12/05/2015
-add more cam/playback controls [done]
-make constants in compute shaders into uniforms [done]
-DEBUG THE SIMULATION
	-the 563 sim counts triangle edges as well. would this help with stability? -> removing them in 563 doesn't change that sim's stability
	-increasing iterations per timestep improves stability to a point, but things still go crazy
	-decreasing timestep doesn't help
	-behavior changes significantly if I reverse the order in which the constraints are projected
	-there's... a phantom pin?
	-ok part of the stability problem: a whole internal constraint buffer was getting overwritten b/c forgot to bind another buffer later before uploading a bunch of bogus
-add naive mesh collision detect!

12/04/2015

TODO
-clean pipeline. eyeball debug.
	-can we merge damp velocities and predict positions? -> except damp velocities could end up quite complex. so not yet.
	-RENAME THINGS RIGHT
	-make constants uniforms!

-debug simulation stability
	-why is there still instability with no constraint projection? numerical error?
	-hmmm... was doing v = v + f instead of v = v + f * dt. seems a little better. [done]

-do proper damping
	-may need to look at and implement scan algorithm
	-assess the CPU version w/out damping. does that solve our stability problem?
	-doesn't look like damping is the source of instability

-add obj checking and constraint generation
-ask Kai about suggestions on animation import formats
	-bvh + obj + skin weights? autoskin in the app if can't export weights?
		-also, writing a bvh player won't be easy
	-borrow from the current 462 bvh player?
	-something like obj sequence or baked fbx isn't good, too slow to load each frame

12/01/2015
-so the vec4 thing is part of std430: buffers are always treated as vec4s, although you can interpret as vec3s in the shader -> thanks Kai!
-we can get things back from the GPU! all about the bufMask. see the writeup -> thanks Kai!
-

11/30/2015
TODO
-fix upload constraints [needs testing]
-modify ppd constraint shader to do pins [needs testing]
-link up the shaders [needs testing]
-test test test
-if there's time: mesh collision step?

11/29/2015
-so there's something wrong with drawing imported meshes right now
-I STRONGLY suspect it's the geometry shader

TODO
-get meshes drawing [done, I think]
-strip out old code for generating meshes and constraints -> correction: add a "simualtion" class [done]
-get meshes importing drawing -> correciton: add a "simulation" class [done]
-pbd shaders [done, needs testing]
	-external forces
	-damp velocities (something basic for now)
	-predict positions
	-project constraints (however many times)

	ScalarType k_prime = 1 - std::pow(1-*(m_p_pbd_stiffness), 1.0/ns); // just like in Muller eh?

	EigenVector3 p1 = x.block_vector(m_p1);
	EigenVector3 p2 = x.block_vector(m_p2);

	ScalarType dist = (p1 - p2).norm();

	ScalarType w = 0.5f; // is this okay? it's w1 / (w1 + w2), but w1 == w2 right?

	EigenVector3 dp1 = -w * (dist - m_rest_length) * (p1 - p2) / dist;
	EigenVector3 dp2 = -1.0f * dp1;

	x.block_vector(m_p1) += k_prime * dp1;
	x.block_vector(m_p2) += k_prime * dp2;

	-update positions and velocities
-pbd pipeline

11/28/2015
-post Thanksgiving!
-took a look at PBD paper, b/c Harmony suggested implementing PBD instead
-also took a look at the PBD hw
-we may just reject bending constraints for now. add them in if necessary

PBD
-so PBD does an explicit euler step with external forces and then corrects resulting positions and velocities using constraints
-in this case, the constraints are cloth-y -> mass spring system
-so it's "unconditionally stable"
-presumably each step in the PBD will need to be its own shader
-when we get to collision detect, we'll also need to add shader collision check -> mmmm
	-perhaps we'll need another buffer of "collisions" per point
	-b/c if there's n points there's at most n collision constraints, right?
	-how to deal with edges... an ongoing problem

TODO
-make "cloth" and "noncloth" classes [done]
	-need to have GL pointers to buffers
-get obj loading and drawing working
-add additional kernels

11/23-24/2015
TODO:
-figure out what's causing drawing in weird space. ask Kai? [done, vec4 vs vec3]
-move mesh into its own class. load an obj instead of doing your jank thing
	-needs to hold its own pointers to buffers and stuff
	-can we put the GL calls in there? or would it make more sense for this to be a struct?
-figure out how to draw polys (read about geometry shaders)
-read up on compute shader memory
-add a plane and some basic shading

-okay. the lack of atomics for floats is a problem. options:
	-look into manually locking
	-look into adding an int buffer to do something
	-float packing (bad idea?)
	-pack the constraints so there's no interference. -> this is Kai sanctioned
		-there's at most 8 constraints influencing each point, we need 8 buffers this way
		-in theory if the mesh is big enough we don't even have to worry about GPU saturation problems
		-and locks/atomics basically serialize too, right?

11/23/2015
BASIC INTEGRATOR NOTES
-we'll do a basic euler for now
-steps:
	-compute forces
	-compute external forces
	-resolve constraints
	-damp velocity
	-render
-we'll also try ping-ponging
-but how to compute forces? -> I... guess we didn't have to do this -> actually, we did
-so go read the 563 HW writeup

IMPLEMENTATION NOTES AND QUESTIONS
-we need a datastructure to show connectivity
-how are we going to go from vertices to triangles? hmmm...

BASIC INTEGRATOR WORKFLOW AND REQUIREMENTS
-so we need a buffer of constraints
	-we can use vec3s for these: -> can we just adapt the acceleration buffer? probably.
		-x = point idx 1
		-y = point idx 2
		-z = rest length
	-we'll need a force buffer if we're parallelizing over constraints -> should just be another vec3
		-may need to use atomics to do force accumulation
	-for now we'll hardcode that indices N - 2 and N - 1 are fixed constraints

	1) kernel -> compute external forces -> easy peasy? for now
	2) kernel -> for each constraint, compute internal force contribution
	3) kernel -> integrate explicit euler -> kernel
	4) kernel -> damp velocity
	5) draw

TODO:
-add host buffers. modify position generation to produce a grid [done, I think?]
-generate vec3 constraints [done, I think?]
-add new compute shaders and setup [done, I think?]
-add compute step invocations [done, I think?]